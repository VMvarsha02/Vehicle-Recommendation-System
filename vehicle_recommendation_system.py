# -*- coding: utf-8 -*-
"""Vehicle_Recommendation_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xDyjJXGD-m31RErjmfq7FFO2SQPXbRHZ
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import silhouette_score, accuracy_score

import io
from google.colab import files

uploaded = files.upload()

file_name = list(uploaded.keys())[0]
print(file_name)

bike = pd.read_csv(io.BytesIO(uploaded[file_name]))
print(bike.head(10))

bike.info()
print(f"\nShape of the dataset: {bike.shape}")
print(f"\nMissing values:\n{bike.isnull().sum()}")

bike = bike.dropna()
bike = bike.drop(columns=['Unnamed: 0'])

print(f"\nShape of the dataset: {bike.shape}")
print(f"\nMissing values:\n{bike.isnull().sum()}")

bike['Price'] = bike['Price'].str.replace(r'\D', '', regex=True)
bike['CC'] = bike['CC'].str.replace(r'\D', '', regex=True)
bike['Mileage'] = bike['Mileage'].str.replace(r'\D', '', regex=True)
bike['Weight'] = bike['Weight'].str.replace(r'\D', '', regex=True)

bike['Price'] = bike['Price'].astype(int)
bike['CC'] = bike['CC'].astype(int)
bike['Mileage'] = bike['Mileage'].astype(int)
bike['Weight'] = bike['Weight'].astype(int)

print(bike.dtypes)

bike.head(100)

df_2dhist = pd.DataFrame({
    x_label: grp['Links'].value_counts()
    for x_label, grp in _df_24.groupby('Model Name')
})
sns.heatmap(df_2dhist, cmap='viridis')
plt.xlabel('Model Name')
_ = plt.ylabel('Links')

_df_21['CC'].plot(kind='line', figsize=(8, 4), title='CC')
plt.gca().spines[['top', 'right']].set_visible(False)

_df_15.groupby('Model Name').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

_df_12['CC'].plot(kind='hist', bins=20, title='CC')
plt.gca().spines[['top', 'right',]].set_visible(False)

_df_11['Price'].plot(kind='hist', bins=20, title='Price')
plt.gca().spines[['top', 'right',]].set_visible(False)

class VehicleRecommendationSystem:
    def __init__(self, bike_data):
        # Feature selection
        self.bike_data = bike_data
        self.x = bike_data[['Price', 'CC', 'Mileage', 'Weight']]
        self.y = bike_data[['Model Name', 'Links']]
        # Train-test split
        self.x_train, self.x_test, self.y_train, self.y_test = train_test_split(self.x, self.y, test_size=0.2, random_state=42)
        # Feature scaling
        self.scaler = StandardScaler()
        self.x_train_scaled = self.scaler.fit_transform(self.x_train)
        self.x_test_scaled = self.scaler.transform(self.x_test)

    def determine_optimal_clusters(self):
        inertia = []
        for i in range(1, 11):
            kmeans = KMeans(n_clusters=i, random_state=42)
            kmeans.fit(self.x_train_scaled)
            inertia.append(kmeans.inertia_)
        plt.plot(range(1, 11), inertia, marker='o')
        plt.title('Elbow Method for Optimal k')
        plt.xlabel('Number of Clusters (k)')
        plt.ylabel('Inertia')
        plt.show()

    def train_kmeans_model(self, n_clusters=5):
        self.kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        self.kmeans.fit(self.x_train_scaled)
        self.train_labels = self.kmeans.labels_

    def train_knn_model(self):
        self.knn = NearestNeighbors(n_neighbors=5)
        self.knn.fit(self.x_train_scaled)

    def evaluate_model(self):
        distances, indices = self.knn.kneighbors(self.x_test_scaled)
        test_labels = [self.train_labels[i[0]] for i in indices]
        silhouette_avg = silhouette_score(self.x_test_scaled, test_labels)
        print(f'Silhouette Score: {silhouette_avg}')
        accuracy = accuracy_score(self.y_test['Model Name'], [self.y_train['Model Name'].iloc[i] for i in indices[:, 0]])
        print(f'Accuracy Score: {accuracy}')

    def make_prediction(self, price, cc, mileage, weight):
        new_data = [[price, cc, mileage, weight]]
        new_data_scaled = self.scaler.transform(new_data)
        distances, indices = self.knn.kneighbors(new_data_scaled)
        predicted_model_name = self.y_train['Model Name'].iloc[indices[0][0]]
        predicted_links = self.y_train['Links'].iloc[indices[0][0]]
        return predicted_model_name, predicted_links

    def visualize_clusters(self):
        """Generate scatter plots with clusters for both Price vs CC and Mileage vs Weight."""
        plt.figure(figsize=(14, 6))

        # First plot: Price vs CC with clusters
        plt.subplot(1, 2, 1)
        sns.scatterplot(x='Price', y='CC', hue=self.train_labels, data=self.x_train, palette='viridis')
        plt.title('Bike Clusters Based on Price and CC')
        plt.xlabel('Price')
        plt.ylabel('CC')

        # Second plot: Mileage vs Weight with clusters
        plt.subplot(1, 2, 2)
        sns.scatterplot(x='Mileage', y='Weight', hue=self.train_labels, data=self.x_train, palette='plasma')
        plt.title('Bike Clusters Based on Mileage and Weight')
        plt.xlabel('Mileage')
        plt.ylabel('Weight')

        plt.tight_layout()
        plt.show()

    def run_system(self):
        self.determine_optimal_clusters()
        self.train_kmeans_model()
        self.train_knn_model()
        self.evaluate_model()
        self.visualize_clusters()

        while True:
            price = float(input("Enter the price: "))
            cc = int(input("Enter the CC: "))
            mileage = int(input("Enter the mileage: "))
            weight = int(input("Enter the weight: "))
            predicted_model_name, predicted_links = self.make_prediction(price, cc, mileage, weight)
            print(f"Predicted model name: {predicted_model_name}")
            print(f"Predicted links: {predicted_links}")
            continue_prediction = input("Do you want to make another prediction? (yes/no): ")
            if continue_prediction.lower() != "yes":
                break

# Initialize and run the system
if __name__ == "__main__":
    sample_x_values = []
    system = VehicleRecommendationSystem(bike)
    system.run_system()

    for x_value in sample_x_values:
        predicted_model_name, predicted_links = system.make_prediction(x_value[0], x_value[1], x_value[2], x_value[3])
        print(f"Predicted model name for x={x_value}: {predicted_model_name}")
        print(f"Predicted links for x={x_value}: {predicted_links}")
        print()

min_price = round(bike['Price'].min(), -3)
min_cc = round(bike['CC'].min(), -1)
min_mileage = round(bike['Mileage'].min(), -1)
min_weight = round(bike['Weight'].min(), -1)

import ipywidgets as widgets

# Input fields
price_input = widgets.IntText(value=min_price, description='Price:')
cc_input = widgets.IntText(value=min_cc, description='CC:')
mileage_input = widgets.IntText(value=min_mileage, description='Mileage:')
weight_input = widgets.IntText(value=min_weight, description='Weight:')

predict_button = widgets.Button(description='Get Recommendations')

# Output area
output_area = widgets.Output()

# Function to handle the button click
def predict_vehicle(b):
    # Input
    price = price_input.value
    cc = cc_input.value
    mileage = mileage_input.value
    weight = weight_input.value

    # Call Prediction function
    predicted_model_name, predicted_links = system.make_prediction(price, cc, mileage, weight)

    # Output
    with output_area:
        print(f'Recommended Model: {predicted_model_name}')
        print(f'Links: {predicted_links}')

# Button to function link
predict_button.on_click(predict_vehicle)

def predict_vehicle(b):
    # Input
    price = price_input.value
    cc = cc_input.value
    mileage = mileage_input.value
    weight = weight_input.value

    # Call Prediction function
    predicted_model_name, predicted_links = system.make_prediction(price, cc, mileage, weight)

    # Output
    with output_area:
        output_area.clear_output()  # Clear previous output
        print("üîç Minimum Values from Dataset:")
        print(f"‚Ä¢ Price: ‚Çπ{min_price}")
        print(f"‚Ä¢ CC: {min_cc} cc")
        print(f"‚Ä¢ Mileage: {min_mileage} kmpl")
        print(f"‚Ä¢ Weight: {min_weight} kg\n")

        print("üö≤ Recommended Vehicle:")
        print(f"‚Ä¢ Model: {predicted_model_name}")
        print(f"‚Ä¢ Link: {predicted_links}")


# Display Interface
display(price_input)
display(cc_input)
display(mileage_input)
display(weight_input)
display(predict_button)
display(output_area)

